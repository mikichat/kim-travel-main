네, Node.js와 Express, EJS 템플릿 엔진을 사용하면 요청하신 기능을 훌륭하게 구현할 수 있습니다.

전체적인 흐름은 \*\*[HTML 폼 → Express 서버(Multer) → Gemini API (파일 전송) → SQLite3 → EJS 뷰(HTML 테이블)]\*\*가 됩니다.

가장 큰 특징은 **Python/Pandas 없이 Node.js에서 직접 `.xlsx` 파일을 바이너리(Base64)로 변환**하여 Gemini 1.5 Pro와 같은 최신 모델에 전송하는 것입니다.

-----

## 💻 개발 단계별 가이드

### 1단계: 프로젝트 설정 및 라이브러리 설치

1.  프로젝트 폴더를 만들고 npm을 시작합니다.
    ```bash
    mkdir gemini-schedule-app
    cd gemini-schedule-app
    npm init -y
    ```
2.  필요한 라이브러리를 설치합니다.
      * **express**: 웹 서버 프레임워크
      * **multer**: 파일 업로드 처리를 위한 미들웨어
      * **@google/generative-ai**: Google Gemini API 공식 SDK
      * **sqlite3**: SQLite 데이터베이스 드라이버
      * **ejs**: HTML 템플릿 엔진 (뷰 페이지 생성용)
      * **dotenv**: API 키를 환경 변수로 관리
    <!-- end list -->
    ```bash
    npm install express multer @google/generative-ai sqlite3 ejs dotenv
    ```
3.  프로젝트 구조를 만듭니다.
    ```
    /gemini-schedule-app
      |-- /views             <-- EJS 템플릿 파일
      |   |-- upload.ejs
      |   |-- schedule.ejs
      |-- /uploads           <-- 업로드된 파일 임시 저장
      |-- .env               <-- API 키 저장
      |-- init_db.js         <-- DB 초기화 스크립트
      |-- server.js          <-- 메인 서버 파일
      |-- package.json
    ```
4.  `.env` 파일을 생성하고 Gemini API 키를 입력합니다.
    **`.env`**
    ```
    GEMINI_API_KEY=여기에_발급받은_API_키를_입력하세요
    ```
5.  `uploads` 폴더를 생성합니다.

-----

### 2단계: SQLite3 데이터베이스 설정

테이블을 미리 생성하는 스크립트입니다.

**`init_db.js`**

```javascript
const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database('schedule.db');

db.serialize(() => {
  // 'schedules' 테이블 생성
  db.run(`
    CREATE TABLE IF NOT EXISTS schedules (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      event_name TEXT NOT NULL,
      event_date TEXT,
      location TEXT,
      description TEXT
    )
  `, (err) => {
    if (err) {
      console.error(err.message);
    } else {
      console.log('테이블이 성공적으로 생성되었습니다.');
    }
  });
});

db.close();
```

터미널에서 `node init_db.js`를 실행하여 `schedule.db` 파일을 생성합니다.

-----

### 3단계: 프런트엔드 (EJS 뷰) 생성

HTML 템플릿 2개를 `views/` 폴더 안에 만듭니다.

**`views/upload.ejs`** (파일 업로드 페이지)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>일정표 업로드</title>
</head>
<body>
    <h2>일정표 (.xlsx) 파일 업로드</h2>
    <form action="/upload" method="post" enctype="multipart/form-data">
        <input type="file" name="scheduleFile" accept=".xlsx" required>
        <button type="submit">추출 및 저장</button>
    </form>
    <br>
    <a href="/schedule">저장된 일정 보기</a>
</body>
</html>
```

**`views/schedule.ejs`** (DB 데이터 표시 페이지)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>저장된 일정표</title>
    <style>
        table { border-collapse: collapse; width: 80%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h2>저장된 일정 목록</h2>
    <table>
        <thead>
            <tr>
                <th>일정명</th>
                <th>날짜</th>
                <th>장소</th>
                <th>설명</th>
            </tr>
        </thead>
        <tbody>
            <% schedules.forEach(schedule => { %>
                <tr>
                    <td><%= schedule.event_name %></td>
                    <td><%= schedule.event_date %></td>
                    <td><%= schedule.location %></td>
                    <td><%= schedule.description %></td>
                </tr>
            <% }) %>
        </tbody>
    </table>
    <br>
    <a href="/">새 파일 업로드하기</a>
</body>
</html>
```

-----

### 4단계: Express 백엔드 서버 구축 (server.js)

이 파일이 모든 핵심 로직을 처리합니다.

**`server.js`**

````javascript
require('dotenv').config();
const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const { GoogleGenerativeAI } = require('@google/generative-ai');

const app = express();
const port = 3000;

// EJS 템플릿 엔진 설정
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Multer 설정 (파일을 'uploads/' 폴더에 임시 저장)
const upload = multer({ dest: 'uploads/' });

// SQLite DB 연결
const db = new sqlite3.Database('schedule.db', (err) => {
  if (err) console.error('DB 연결 오류:', err.message);
  else console.log('SQLite DB에 연결되었습니다.');
});

// Gemini API 설정 (파일 업로드를 지원하는 모델 사용)
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' }); // 1.5 Pro 또는 Flash

// --- 라우트(Routes) 설정 ---

// 1. 메인 페이지 (파일 업로드 폼)
app.get('/', (req, res) => {
  res.render('upload');
});

// 2. 파일 업로드 및 처리
app.post('/upload', upload.single('scheduleFile'), async (req, res) => {
  if (!req.file) {
    return res.status(400).send('파일이 업로드되지 않았습니다.');
  }

  const filePath = req.file.path;
  const mimeType = req.file.mimetype; // Multer가 자동으로 MIME 타입 감지

  try {
    // --- 4-1. Gemini API로 파일 전송 및 데이터 추출 ---
    
    // 1. 파일을 Base64로 인코딩
    const fileBuffer = fs.readFileSync(filePath);
    const base64Data = fileBuffer.toString('base64');

    // 2. Gemini API에 전송할 파일 파트 생성
    const filePart = {
      inlineData: {
        data: base64Data,
        mimeType: mimeType 
        // (정확히는 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
      },
    };

    // 3. 프롬프트와 파일 파트를 함께 전송
    const prompt = `
      첨부된 Excel (xlsx) 파일에서 일정 데이터를 추출해줘.
      결과는 반드시 다음 키를 포함하는 JSON 배열 형태로만 반환해줘:
      ['event_name', 'event_date', 'location', 'description']
      날짜는 'YYYY-MM-DD' 형식으로 통일하고, 알 수 없는 값은 null로 처리해줘.
      JSON 데이터 외에 다른 설명은 절대 추가하지 마.
    `;

    const result = await model.generateContent([prompt, filePart]);
    const responseText = result.response.text();
    
    // 4. Gemini 응답(JSON) 파싱
    // Gemini가 ```json ... ``` 마크다운을 포함할 수 있으므로 제거
    const jsonString = responseText.replace(/```json|```/g, '').trim();
    const schedules = JSON.parse(jsonString);

    // --- 4-2. SQLite3에 데이터 저장 ---
    const stmt = db.prepare("INSERT INTO schedules (event_name, event_date, location, description) VALUES (?, ?, ?, ?)");
    
    db.serialize(() => {
      schedules.forEach(item => {
        stmt.run(
          item.event_name,
          item.event_date,
          item.location,
          item.description
        );
      });
      stmt.finalize();
    });

    // 5. 임시 파일 삭제
    fs.unlinkSync(filePath);

    // 6. 결과 페이지로 리디렉션
    res.redirect('/schedule');

  } catch (error) {
    console.error('업로드 처리 중 오류 발생:', error);
    fs.unlinkSync(filePath); // 오류 발생 시에도 임시 파일 삭제
    res.status(500).send('데이터 처리 중 오류가 발생했습니다.');
  }
});

// 3. 저장된 일정 보기 (DB에서 조회)
app.get('/schedule', (req, res) => {
  db.all("SELECT * FROM schedules ORDER BY event_date DESC", [], (err, rows) => {
    if (err) {
      return res.status(500).send('데이터를 불러오는 중 오류가 발생했습니다.');
    }
    // 'schedule.ejs' 템플릿을 렌더링하면서 DB에서 가져온 'rows' 데이터를 전달
    res.render('schedule', { schedules: rows });
  });
});

app.listen(port, () => {
  console.log(`서버가 http://localhost:${port 에서 실행 중입니다.`);
});
````

-----

### 5단계: 실행 및 테스트

1.  (최초 1회) DB 테이블을 생성합니다.
    ```bash
    node init_db.js
    ```
2.  메인 서버를 실행합니다.
    ```bash
    node server.js
    ```
3.  브라우저에서 `http://localhost:3000`에 접속하여 `일정표.xlsx` 파일을 업로드합니다.
4.  처리가 완료되면 자동으로 `/schedule` 페이지로 이동하며, DB에 저장된 내용이 테이블로 보입니다.

-----

## 💡 주요 고려사항 및 핵심 포인트

  * **Gemini 모델 선택:** 이 기능은 `.xlsx`와 같은 바이너리 파일을 직접 이해할 수 있는 **Gemini 1.5 Flash** 또는 **1.5 Pro** 모델이 필요합니다.
  * **MIME 타입:** `multer`가 파일의 MIME 타입을 (`req.file.mimetype`) 감지해 주므로, 이 값을 Gemini API에 그대로 전달하는 것이 중요합니다.
  * **프롬프트 엔지니어링:** `server.js`의 `prompt` 변수 내용이 매우 중요합니다. Gemini가 **반드시 JSON 형식으로만** 응답하도록 강력하게 지시해야 파싱 오류가 발생하지 않습니다.
  * **대용량 파일:** 이 방식은 파일을 서버 메모리에 로드(Base64 인코딩)하므로, 수십 MB가 넘는 매우 큰 Excel 파일에는 적합하지 않을 수 있습니다. (Gemini API의 파일 크기 제한도 확인해야 합니다.)
  * **데이터 정제:** Gemini가 반환한 JSON 텍스트에 ` ```json ` 같은 마크다운이 포함될 수 있으므로, `JSON.parse()`를 호출하기 전에 `replace()`로 제거하는 작업이 필요합니다.