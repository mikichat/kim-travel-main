말씀하신 내용이 정확합니다. CSV는 데이터를 쉼표로 구분한 '순수 텍스트'일 뿐이라, **병합된 셀, 행 높이, 열 너비, 색상 등 원본 Excel의 모든 '구조'와 '서식' 정보가 사라집니다.**

Gemini가 일정표를 정확히 이해하려면 데이터뿐만 아니라, "이 셀이 여러 날짜에 걸쳐있다" (셀 병합) 같은 **구조적 문맥**이 매우 중요합니다.

-----

## 💡 가장 좋은 해결책: XLSX → HTML로 변환 후 전송

가장 좋은 방법은 `xlsx` (sheetjs) 라이브러리를 사용해 Excel 시트를 **CSV가 아닌 HTML `<table>` 태그로 변환**하여 Gemini에게 텍스트로 전송하는 것입니다.

이 방법은 **새로운 라이브러리 설치 없이** `xlsx`만으로 가능하며, **셀 병합 정보(`rowspan`, `colspan`)를 완벽하게 보존**합니다. Gemini는 HTML 테이블 구조를 매우 잘 이해합니다.

### 1\. `xlsx` 라이브러리 확인 (이미 설치됨)

(이전에 CSV 변환을 위해 이미 `npm install xlsx`를 하셨습니다.)

### 2\. `server.js` 수정

`app.post('/upload', ...)` 핸들러 로직을 **HTML로 변환**하도록 변경합니다.

**`server.js` 의 핵심 수정 부분**

```javascript
// ... (기존 require)
const xlsx = require('xlsx'); // <--- xlsx 라이브러리
const fs = require('fs');

// ...

// 2. 파일 업로드 및 처리
app.post('/upload', upload.single('scheduleFile'), async (req, res) => {
  if (!req.file) {
    return res.status(400).send('파일이 업로드되지 않았습니다.');
  }

  const filePath = req.file.path;

  try {
    // --- (수정) 1. XLSX 파일을 읽어 'HTML' 텍스트로 변환 ---
    const workbook = xlsx.readFile(filePath);
    const sheetName = workbook.SheetNames[0]; // 첫 번째 시트
    const worksheet = workbook.Sheets[sheetName];
    
    // 이 부분이 핵심입니다: CSV 대신 HTML로 변환
    const htmlData = xlsx.utils.sheet_to_html(worksHS, { header: '' }); // header: '' 옵션으로 불필요한 <thead> 제거

    // --- (수정) 2. Gemini API에 'HTML 텍스트' 전송 ---
    const prompt = `
      다음은 HTML <table> 형식의 일정표 데이터입니다.
      이 HTML 구조(특히 colspan과 rowspan으로 병합된 셀)를 주의 깊게 분석해서,
      각 일정 항목을 'event_name', 'event_date', 'location', 'description' 키를 가진 JSON 배열로 만들어주세요.

      - 날짜는 'YYYY-MM-DD' 형식으로 통일해 주세요.
      - 병합된 셀에 걸쳐 있는 일정은 날짜별로 개별 항목으로 나누거나, 시작일과 종료일을 명시해 주세요.
      - JSON 데이터 외에 다른 설명(예: \`\`\`json)은 절대 추가하지 마세요.

      [HTML 데이터]
      ${htmlData}
    `;

    // (주의) 1.5-flash 또는 1.5-pro 모델 사용
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    
    // 텍스트 프롬프트만 전송
    const result = await model.generateContent(prompt);
    const responseText = result.response.text();
    
    // 3. Gemini 응답(JSON) 파싱
    const schedules = JSON.parse(responseText.trim());

    // --- 4. SQLite3에 데이터 저장 (이 부분은 동일) ---
    const stmt = db.prepare("INSERT INTO schedules (event_name, event_date, location, description) VALUES (?, ?, ?, ?)");
    
    db.serialize(() => {
      schedules.forEach(item => {
        stmt.run(
          item.event_name,
          item.event_date,
          item.location,
          item.description
        );
      });
      stmt.finalize();
    });

    // 5. 임시 파일 삭제
    fs.unlinkSync(filePath);

    // 6. 결과 페이지로 리디렉션
    res.redirect('/schedule');

  } catch (error) {
    console.error('업로드 처리 중 오류 발생:', error);
    // Gemini가 JSON이 아닌 텍스트를 반환했는지 확인 (파싱 오류)
    if (error instanceof SyntaxError) {
        console.error("Gemini가 유효한 JSON을 반환하지 않았습니다. 응답 텍스트:", error.message);
    }
    fs.unlinkSync(filePath); // 오류 발생 시에도 임시 파일 삭제
    res.status(500).send('데이터 처리 중 오류가 발생했습니다. (Gemini 응답 또는 DB 오류)');
  }
});

// ... (이하 코드 동일)
```

-----

## ✅ 이 방법이 더 좋은 이유

1.  **구조 유지:** Excel의 **셀 병합** 정보가 HTML의 `rowspan` (행 병합), `colspan` (열 병합) 태그로 완벽하게 변환됩니다.
2.  **높은 정확도:** Gemini는 텍스트 기반인 HTML 구조를 분석하는 데 매우 뛰어나며, 병합된 셀의 문맥을 이해하여 "3일간 진행되는 행사" 등을 정확하게 추출할 수 있습니다.
3.  **간편함:** PDF 변환 등 별도의 복잡한 도구 없이, 기존의 `xlsx` 라이브러리 하나로 모든 변환이 끝납니다.
4.  **오류 해결:** `Unsupported MIME type` 오류를 근본적으로 해결합니다. (파일 자체가 아닌, Gemini가 가장 잘 이해하는 '텍스트'를 보내기 때문)